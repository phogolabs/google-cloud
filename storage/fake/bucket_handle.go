// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"context"
	"sync"

	"cloud.google.com/go/iam"
	storagea "cloud.google.com/go/storage"
	"github.com/phogolabs/google-cloud/storage"
)

type FakeBucketHandle struct {
	ACLStub        func() storage.ACLHandle
	aCLMutex       sync.RWMutex
	aCLArgsForCall []struct {
	}
	aCLReturns struct {
		result1 storage.ACLHandle
	}
	aCLReturnsOnCall map[int]struct {
		result1 storage.ACLHandle
	}
	AddNotificationStub        func(context.Context, *storagea.Notification) (*storagea.Notification, error)
	addNotificationMutex       sync.RWMutex
	addNotificationArgsForCall []struct {
		arg1 context.Context
		arg2 *storagea.Notification
	}
	addNotificationReturns struct {
		result1 *storagea.Notification
		result2 error
	}
	addNotificationReturnsOnCall map[int]struct {
		result1 *storagea.Notification
		result2 error
	}
	AttrsStub        func(context.Context) (*storagea.BucketAttrs, error)
	attrsMutex       sync.RWMutex
	attrsArgsForCall []struct {
		arg1 context.Context
	}
	attrsReturns struct {
		result1 *storagea.BucketAttrs
		result2 error
	}
	attrsReturnsOnCall map[int]struct {
		result1 *storagea.BucketAttrs
		result2 error
	}
	CreateStub        func(context.Context, string, *storagea.BucketAttrs) error
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *storagea.BucketAttrs
	}
	createReturns struct {
		result1 error
	}
	createReturnsOnCall map[int]struct {
		result1 error
	}
	DefaultObjectACLStub        func() storage.ACLHandle
	defaultObjectACLMutex       sync.RWMutex
	defaultObjectACLArgsForCall []struct {
	}
	defaultObjectACLReturns struct {
		result1 storage.ACLHandle
	}
	defaultObjectACLReturnsOnCall map[int]struct {
		result1 storage.ACLHandle
	}
	DeleteStub        func(context.Context) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 context.Context
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteNotificationStub        func(context.Context, string) error
	deleteNotificationMutex       sync.RWMutex
	deleteNotificationArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	deleteNotificationReturns struct {
		result1 error
	}
	deleteNotificationReturnsOnCall map[int]struct {
		result1 error
	}
	IAMStub        func() *iam.Handle
	iAMMutex       sync.RWMutex
	iAMArgsForCall []struct {
	}
	iAMReturns struct {
		result1 *iam.Handle
	}
	iAMReturnsOnCall map[int]struct {
		result1 *iam.Handle
	}
	IfStub        func(storagea.BucketConditions) storage.BucketHandle
	ifMutex       sync.RWMutex
	ifArgsForCall []struct {
		arg1 storagea.BucketConditions
	}
	ifReturns struct {
		result1 storage.BucketHandle
	}
	ifReturnsOnCall map[int]struct {
		result1 storage.BucketHandle
	}
	LockRetentionPolicyStub        func(context.Context) error
	lockRetentionPolicyMutex       sync.RWMutex
	lockRetentionPolicyArgsForCall []struct {
		arg1 context.Context
	}
	lockRetentionPolicyReturns struct {
		result1 error
	}
	lockRetentionPolicyReturnsOnCall map[int]struct {
		result1 error
	}
	NotificationsStub        func(context.Context) (map[string]*storagea.Notification, error)
	notificationsMutex       sync.RWMutex
	notificationsArgsForCall []struct {
		arg1 context.Context
	}
	notificationsReturns struct {
		result1 map[string]*storagea.Notification
		result2 error
	}
	notificationsReturnsOnCall map[int]struct {
		result1 map[string]*storagea.Notification
		result2 error
	}
	ObjectStub        func(string) storage.ObjectHandle
	objectMutex       sync.RWMutex
	objectArgsForCall []struct {
		arg1 string
	}
	objectReturns struct {
		result1 storage.ObjectHandle
	}
	objectReturnsOnCall map[int]struct {
		result1 storage.ObjectHandle
	}
	ObjectsStub        func(context.Context, *storagea.Query) storage.ObjectIterator
	objectsMutex       sync.RWMutex
	objectsArgsForCall []struct {
		arg1 context.Context
		arg2 *storagea.Query
	}
	objectsReturns struct {
		result1 storage.ObjectIterator
	}
	objectsReturnsOnCall map[int]struct {
		result1 storage.ObjectIterator
	}
	UpdateStub        func(context.Context, storagea.BucketAttrsToUpdate) (*storagea.BucketAttrs, error)
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 context.Context
		arg2 storagea.BucketAttrsToUpdate
	}
	updateReturns struct {
		result1 *storagea.BucketAttrs
		result2 error
	}
	updateReturnsOnCall map[int]struct {
		result1 *storagea.BucketAttrs
		result2 error
	}
	UserProjectStub        func(string) storage.BucketHandle
	userProjectMutex       sync.RWMutex
	userProjectArgsForCall []struct {
		arg1 string
	}
	userProjectReturns struct {
		result1 storage.BucketHandle
	}
	userProjectReturnsOnCall map[int]struct {
		result1 storage.BucketHandle
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBucketHandle) ACL() storage.ACLHandle {
	fake.aCLMutex.Lock()
	ret, specificReturn := fake.aCLReturnsOnCall[len(fake.aCLArgsForCall)]
	fake.aCLArgsForCall = append(fake.aCLArgsForCall, struct {
	}{})
	stub := fake.ACLStub
	fakeReturns := fake.aCLReturns
	fake.recordInvocation("ACL", []interface{}{})
	fake.aCLMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBucketHandle) ACLCallCount() int {
	fake.aCLMutex.RLock()
	defer fake.aCLMutex.RUnlock()
	return len(fake.aCLArgsForCall)
}

func (fake *FakeBucketHandle) ACLCalls(stub func() storage.ACLHandle) {
	fake.aCLMutex.Lock()
	defer fake.aCLMutex.Unlock()
	fake.ACLStub = stub
}

func (fake *FakeBucketHandle) ACLReturns(result1 storage.ACLHandle) {
	fake.aCLMutex.Lock()
	defer fake.aCLMutex.Unlock()
	fake.ACLStub = nil
	fake.aCLReturns = struct {
		result1 storage.ACLHandle
	}{result1}
}

func (fake *FakeBucketHandle) ACLReturnsOnCall(i int, result1 storage.ACLHandle) {
	fake.aCLMutex.Lock()
	defer fake.aCLMutex.Unlock()
	fake.ACLStub = nil
	if fake.aCLReturnsOnCall == nil {
		fake.aCLReturnsOnCall = make(map[int]struct {
			result1 storage.ACLHandle
		})
	}
	fake.aCLReturnsOnCall[i] = struct {
		result1 storage.ACLHandle
	}{result1}
}

func (fake *FakeBucketHandle) AddNotification(arg1 context.Context, arg2 *storagea.Notification) (*storagea.Notification, error) {
	fake.addNotificationMutex.Lock()
	ret, specificReturn := fake.addNotificationReturnsOnCall[len(fake.addNotificationArgsForCall)]
	fake.addNotificationArgsForCall = append(fake.addNotificationArgsForCall, struct {
		arg1 context.Context
		arg2 *storagea.Notification
	}{arg1, arg2})
	stub := fake.AddNotificationStub
	fakeReturns := fake.addNotificationReturns
	fake.recordInvocation("AddNotification", []interface{}{arg1, arg2})
	fake.addNotificationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBucketHandle) AddNotificationCallCount() int {
	fake.addNotificationMutex.RLock()
	defer fake.addNotificationMutex.RUnlock()
	return len(fake.addNotificationArgsForCall)
}

func (fake *FakeBucketHandle) AddNotificationCalls(stub func(context.Context, *storagea.Notification) (*storagea.Notification, error)) {
	fake.addNotificationMutex.Lock()
	defer fake.addNotificationMutex.Unlock()
	fake.AddNotificationStub = stub
}

func (fake *FakeBucketHandle) AddNotificationArgsForCall(i int) (context.Context, *storagea.Notification) {
	fake.addNotificationMutex.RLock()
	defer fake.addNotificationMutex.RUnlock()
	argsForCall := fake.addNotificationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBucketHandle) AddNotificationReturns(result1 *storagea.Notification, result2 error) {
	fake.addNotificationMutex.Lock()
	defer fake.addNotificationMutex.Unlock()
	fake.AddNotificationStub = nil
	fake.addNotificationReturns = struct {
		result1 *storagea.Notification
		result2 error
	}{result1, result2}
}

func (fake *FakeBucketHandle) AddNotificationReturnsOnCall(i int, result1 *storagea.Notification, result2 error) {
	fake.addNotificationMutex.Lock()
	defer fake.addNotificationMutex.Unlock()
	fake.AddNotificationStub = nil
	if fake.addNotificationReturnsOnCall == nil {
		fake.addNotificationReturnsOnCall = make(map[int]struct {
			result1 *storagea.Notification
			result2 error
		})
	}
	fake.addNotificationReturnsOnCall[i] = struct {
		result1 *storagea.Notification
		result2 error
	}{result1, result2}
}

func (fake *FakeBucketHandle) Attrs(arg1 context.Context) (*storagea.BucketAttrs, error) {
	fake.attrsMutex.Lock()
	ret, specificReturn := fake.attrsReturnsOnCall[len(fake.attrsArgsForCall)]
	fake.attrsArgsForCall = append(fake.attrsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.AttrsStub
	fakeReturns := fake.attrsReturns
	fake.recordInvocation("Attrs", []interface{}{arg1})
	fake.attrsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBucketHandle) AttrsCallCount() int {
	fake.attrsMutex.RLock()
	defer fake.attrsMutex.RUnlock()
	return len(fake.attrsArgsForCall)
}

func (fake *FakeBucketHandle) AttrsCalls(stub func(context.Context) (*storagea.BucketAttrs, error)) {
	fake.attrsMutex.Lock()
	defer fake.attrsMutex.Unlock()
	fake.AttrsStub = stub
}

func (fake *FakeBucketHandle) AttrsArgsForCall(i int) context.Context {
	fake.attrsMutex.RLock()
	defer fake.attrsMutex.RUnlock()
	argsForCall := fake.attrsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBucketHandle) AttrsReturns(result1 *storagea.BucketAttrs, result2 error) {
	fake.attrsMutex.Lock()
	defer fake.attrsMutex.Unlock()
	fake.AttrsStub = nil
	fake.attrsReturns = struct {
		result1 *storagea.BucketAttrs
		result2 error
	}{result1, result2}
}

func (fake *FakeBucketHandle) AttrsReturnsOnCall(i int, result1 *storagea.BucketAttrs, result2 error) {
	fake.attrsMutex.Lock()
	defer fake.attrsMutex.Unlock()
	fake.AttrsStub = nil
	if fake.attrsReturnsOnCall == nil {
		fake.attrsReturnsOnCall = make(map[int]struct {
			result1 *storagea.BucketAttrs
			result2 error
		})
	}
	fake.attrsReturnsOnCall[i] = struct {
		result1 *storagea.BucketAttrs
		result2 error
	}{result1, result2}
}

func (fake *FakeBucketHandle) Create(arg1 context.Context, arg2 string, arg3 *storagea.BucketAttrs) error {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *storagea.BucketAttrs
	}{arg1, arg2, arg3})
	stub := fake.CreateStub
	fakeReturns := fake.createReturns
	fake.recordInvocation("Create", []interface{}{arg1, arg2, arg3})
	fake.createMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBucketHandle) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeBucketHandle) CreateCalls(stub func(context.Context, string, *storagea.BucketAttrs) error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = stub
}

func (fake *FakeBucketHandle) CreateArgsForCall(i int) (context.Context, string, *storagea.BucketAttrs) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	argsForCall := fake.createArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBucketHandle) CreateReturns(result1 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBucketHandle) CreateReturnsOnCall(i int, result1 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBucketHandle) DefaultObjectACL() storage.ACLHandle {
	fake.defaultObjectACLMutex.Lock()
	ret, specificReturn := fake.defaultObjectACLReturnsOnCall[len(fake.defaultObjectACLArgsForCall)]
	fake.defaultObjectACLArgsForCall = append(fake.defaultObjectACLArgsForCall, struct {
	}{})
	stub := fake.DefaultObjectACLStub
	fakeReturns := fake.defaultObjectACLReturns
	fake.recordInvocation("DefaultObjectACL", []interface{}{})
	fake.defaultObjectACLMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBucketHandle) DefaultObjectACLCallCount() int {
	fake.defaultObjectACLMutex.RLock()
	defer fake.defaultObjectACLMutex.RUnlock()
	return len(fake.defaultObjectACLArgsForCall)
}

func (fake *FakeBucketHandle) DefaultObjectACLCalls(stub func() storage.ACLHandle) {
	fake.defaultObjectACLMutex.Lock()
	defer fake.defaultObjectACLMutex.Unlock()
	fake.DefaultObjectACLStub = stub
}

func (fake *FakeBucketHandle) DefaultObjectACLReturns(result1 storage.ACLHandle) {
	fake.defaultObjectACLMutex.Lock()
	defer fake.defaultObjectACLMutex.Unlock()
	fake.DefaultObjectACLStub = nil
	fake.defaultObjectACLReturns = struct {
		result1 storage.ACLHandle
	}{result1}
}

func (fake *FakeBucketHandle) DefaultObjectACLReturnsOnCall(i int, result1 storage.ACLHandle) {
	fake.defaultObjectACLMutex.Lock()
	defer fake.defaultObjectACLMutex.Unlock()
	fake.DefaultObjectACLStub = nil
	if fake.defaultObjectACLReturnsOnCall == nil {
		fake.defaultObjectACLReturnsOnCall = make(map[int]struct {
			result1 storage.ACLHandle
		})
	}
	fake.defaultObjectACLReturnsOnCall[i] = struct {
		result1 storage.ACLHandle
	}{result1}
}

func (fake *FakeBucketHandle) Delete(arg1 context.Context) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.DeleteStub
	fakeReturns := fake.deleteReturns
	fake.recordInvocation("Delete", []interface{}{arg1})
	fake.deleteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBucketHandle) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeBucketHandle) DeleteCalls(stub func(context.Context) error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeBucketHandle) DeleteArgsForCall(i int) context.Context {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBucketHandle) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBucketHandle) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBucketHandle) DeleteNotification(arg1 context.Context, arg2 string) error {
	fake.deleteNotificationMutex.Lock()
	ret, specificReturn := fake.deleteNotificationReturnsOnCall[len(fake.deleteNotificationArgsForCall)]
	fake.deleteNotificationArgsForCall = append(fake.deleteNotificationArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteNotificationStub
	fakeReturns := fake.deleteNotificationReturns
	fake.recordInvocation("DeleteNotification", []interface{}{arg1, arg2})
	fake.deleteNotificationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBucketHandle) DeleteNotificationCallCount() int {
	fake.deleteNotificationMutex.RLock()
	defer fake.deleteNotificationMutex.RUnlock()
	return len(fake.deleteNotificationArgsForCall)
}

func (fake *FakeBucketHandle) DeleteNotificationCalls(stub func(context.Context, string) error) {
	fake.deleteNotificationMutex.Lock()
	defer fake.deleteNotificationMutex.Unlock()
	fake.DeleteNotificationStub = stub
}

func (fake *FakeBucketHandle) DeleteNotificationArgsForCall(i int) (context.Context, string) {
	fake.deleteNotificationMutex.RLock()
	defer fake.deleteNotificationMutex.RUnlock()
	argsForCall := fake.deleteNotificationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBucketHandle) DeleteNotificationReturns(result1 error) {
	fake.deleteNotificationMutex.Lock()
	defer fake.deleteNotificationMutex.Unlock()
	fake.DeleteNotificationStub = nil
	fake.deleteNotificationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBucketHandle) DeleteNotificationReturnsOnCall(i int, result1 error) {
	fake.deleteNotificationMutex.Lock()
	defer fake.deleteNotificationMutex.Unlock()
	fake.DeleteNotificationStub = nil
	if fake.deleteNotificationReturnsOnCall == nil {
		fake.deleteNotificationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteNotificationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBucketHandle) IAM() *iam.Handle {
	fake.iAMMutex.Lock()
	ret, specificReturn := fake.iAMReturnsOnCall[len(fake.iAMArgsForCall)]
	fake.iAMArgsForCall = append(fake.iAMArgsForCall, struct {
	}{})
	stub := fake.IAMStub
	fakeReturns := fake.iAMReturns
	fake.recordInvocation("IAM", []interface{}{})
	fake.iAMMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBucketHandle) IAMCallCount() int {
	fake.iAMMutex.RLock()
	defer fake.iAMMutex.RUnlock()
	return len(fake.iAMArgsForCall)
}

func (fake *FakeBucketHandle) IAMCalls(stub func() *iam.Handle) {
	fake.iAMMutex.Lock()
	defer fake.iAMMutex.Unlock()
	fake.IAMStub = stub
}

func (fake *FakeBucketHandle) IAMReturns(result1 *iam.Handle) {
	fake.iAMMutex.Lock()
	defer fake.iAMMutex.Unlock()
	fake.IAMStub = nil
	fake.iAMReturns = struct {
		result1 *iam.Handle
	}{result1}
}

func (fake *FakeBucketHandle) IAMReturnsOnCall(i int, result1 *iam.Handle) {
	fake.iAMMutex.Lock()
	defer fake.iAMMutex.Unlock()
	fake.IAMStub = nil
	if fake.iAMReturnsOnCall == nil {
		fake.iAMReturnsOnCall = make(map[int]struct {
			result1 *iam.Handle
		})
	}
	fake.iAMReturnsOnCall[i] = struct {
		result1 *iam.Handle
	}{result1}
}

func (fake *FakeBucketHandle) If(arg1 storagea.BucketConditions) storage.BucketHandle {
	fake.ifMutex.Lock()
	ret, specificReturn := fake.ifReturnsOnCall[len(fake.ifArgsForCall)]
	fake.ifArgsForCall = append(fake.ifArgsForCall, struct {
		arg1 storagea.BucketConditions
	}{arg1})
	stub := fake.IfStub
	fakeReturns := fake.ifReturns
	fake.recordInvocation("If", []interface{}{arg1})
	fake.ifMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBucketHandle) IfCallCount() int {
	fake.ifMutex.RLock()
	defer fake.ifMutex.RUnlock()
	return len(fake.ifArgsForCall)
}

func (fake *FakeBucketHandle) IfCalls(stub func(storagea.BucketConditions) storage.BucketHandle) {
	fake.ifMutex.Lock()
	defer fake.ifMutex.Unlock()
	fake.IfStub = stub
}

func (fake *FakeBucketHandle) IfArgsForCall(i int) storagea.BucketConditions {
	fake.ifMutex.RLock()
	defer fake.ifMutex.RUnlock()
	argsForCall := fake.ifArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBucketHandle) IfReturns(result1 storage.BucketHandle) {
	fake.ifMutex.Lock()
	defer fake.ifMutex.Unlock()
	fake.IfStub = nil
	fake.ifReturns = struct {
		result1 storage.BucketHandle
	}{result1}
}

func (fake *FakeBucketHandle) IfReturnsOnCall(i int, result1 storage.BucketHandle) {
	fake.ifMutex.Lock()
	defer fake.ifMutex.Unlock()
	fake.IfStub = nil
	if fake.ifReturnsOnCall == nil {
		fake.ifReturnsOnCall = make(map[int]struct {
			result1 storage.BucketHandle
		})
	}
	fake.ifReturnsOnCall[i] = struct {
		result1 storage.BucketHandle
	}{result1}
}

func (fake *FakeBucketHandle) LockRetentionPolicy(arg1 context.Context) error {
	fake.lockRetentionPolicyMutex.Lock()
	ret, specificReturn := fake.lockRetentionPolicyReturnsOnCall[len(fake.lockRetentionPolicyArgsForCall)]
	fake.lockRetentionPolicyArgsForCall = append(fake.lockRetentionPolicyArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.LockRetentionPolicyStub
	fakeReturns := fake.lockRetentionPolicyReturns
	fake.recordInvocation("LockRetentionPolicy", []interface{}{arg1})
	fake.lockRetentionPolicyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBucketHandle) LockRetentionPolicyCallCount() int {
	fake.lockRetentionPolicyMutex.RLock()
	defer fake.lockRetentionPolicyMutex.RUnlock()
	return len(fake.lockRetentionPolicyArgsForCall)
}

func (fake *FakeBucketHandle) LockRetentionPolicyCalls(stub func(context.Context) error) {
	fake.lockRetentionPolicyMutex.Lock()
	defer fake.lockRetentionPolicyMutex.Unlock()
	fake.LockRetentionPolicyStub = stub
}

func (fake *FakeBucketHandle) LockRetentionPolicyArgsForCall(i int) context.Context {
	fake.lockRetentionPolicyMutex.RLock()
	defer fake.lockRetentionPolicyMutex.RUnlock()
	argsForCall := fake.lockRetentionPolicyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBucketHandle) LockRetentionPolicyReturns(result1 error) {
	fake.lockRetentionPolicyMutex.Lock()
	defer fake.lockRetentionPolicyMutex.Unlock()
	fake.LockRetentionPolicyStub = nil
	fake.lockRetentionPolicyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBucketHandle) LockRetentionPolicyReturnsOnCall(i int, result1 error) {
	fake.lockRetentionPolicyMutex.Lock()
	defer fake.lockRetentionPolicyMutex.Unlock()
	fake.LockRetentionPolicyStub = nil
	if fake.lockRetentionPolicyReturnsOnCall == nil {
		fake.lockRetentionPolicyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.lockRetentionPolicyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBucketHandle) Notifications(arg1 context.Context) (map[string]*storagea.Notification, error) {
	fake.notificationsMutex.Lock()
	ret, specificReturn := fake.notificationsReturnsOnCall[len(fake.notificationsArgsForCall)]
	fake.notificationsArgsForCall = append(fake.notificationsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.NotificationsStub
	fakeReturns := fake.notificationsReturns
	fake.recordInvocation("Notifications", []interface{}{arg1})
	fake.notificationsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBucketHandle) NotificationsCallCount() int {
	fake.notificationsMutex.RLock()
	defer fake.notificationsMutex.RUnlock()
	return len(fake.notificationsArgsForCall)
}

func (fake *FakeBucketHandle) NotificationsCalls(stub func(context.Context) (map[string]*storagea.Notification, error)) {
	fake.notificationsMutex.Lock()
	defer fake.notificationsMutex.Unlock()
	fake.NotificationsStub = stub
}

func (fake *FakeBucketHandle) NotificationsArgsForCall(i int) context.Context {
	fake.notificationsMutex.RLock()
	defer fake.notificationsMutex.RUnlock()
	argsForCall := fake.notificationsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBucketHandle) NotificationsReturns(result1 map[string]*storagea.Notification, result2 error) {
	fake.notificationsMutex.Lock()
	defer fake.notificationsMutex.Unlock()
	fake.NotificationsStub = nil
	fake.notificationsReturns = struct {
		result1 map[string]*storagea.Notification
		result2 error
	}{result1, result2}
}

func (fake *FakeBucketHandle) NotificationsReturnsOnCall(i int, result1 map[string]*storagea.Notification, result2 error) {
	fake.notificationsMutex.Lock()
	defer fake.notificationsMutex.Unlock()
	fake.NotificationsStub = nil
	if fake.notificationsReturnsOnCall == nil {
		fake.notificationsReturnsOnCall = make(map[int]struct {
			result1 map[string]*storagea.Notification
			result2 error
		})
	}
	fake.notificationsReturnsOnCall[i] = struct {
		result1 map[string]*storagea.Notification
		result2 error
	}{result1, result2}
}

func (fake *FakeBucketHandle) Object(arg1 string) storage.ObjectHandle {
	fake.objectMutex.Lock()
	ret, specificReturn := fake.objectReturnsOnCall[len(fake.objectArgsForCall)]
	fake.objectArgsForCall = append(fake.objectArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ObjectStub
	fakeReturns := fake.objectReturns
	fake.recordInvocation("Object", []interface{}{arg1})
	fake.objectMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBucketHandle) ObjectCallCount() int {
	fake.objectMutex.RLock()
	defer fake.objectMutex.RUnlock()
	return len(fake.objectArgsForCall)
}

func (fake *FakeBucketHandle) ObjectCalls(stub func(string) storage.ObjectHandle) {
	fake.objectMutex.Lock()
	defer fake.objectMutex.Unlock()
	fake.ObjectStub = stub
}

func (fake *FakeBucketHandle) ObjectArgsForCall(i int) string {
	fake.objectMutex.RLock()
	defer fake.objectMutex.RUnlock()
	argsForCall := fake.objectArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBucketHandle) ObjectReturns(result1 storage.ObjectHandle) {
	fake.objectMutex.Lock()
	defer fake.objectMutex.Unlock()
	fake.ObjectStub = nil
	fake.objectReturns = struct {
		result1 storage.ObjectHandle
	}{result1}
}

func (fake *FakeBucketHandle) ObjectReturnsOnCall(i int, result1 storage.ObjectHandle) {
	fake.objectMutex.Lock()
	defer fake.objectMutex.Unlock()
	fake.ObjectStub = nil
	if fake.objectReturnsOnCall == nil {
		fake.objectReturnsOnCall = make(map[int]struct {
			result1 storage.ObjectHandle
		})
	}
	fake.objectReturnsOnCall[i] = struct {
		result1 storage.ObjectHandle
	}{result1}
}

func (fake *FakeBucketHandle) Objects(arg1 context.Context, arg2 *storagea.Query) storage.ObjectIterator {
	fake.objectsMutex.Lock()
	ret, specificReturn := fake.objectsReturnsOnCall[len(fake.objectsArgsForCall)]
	fake.objectsArgsForCall = append(fake.objectsArgsForCall, struct {
		arg1 context.Context
		arg2 *storagea.Query
	}{arg1, arg2})
	stub := fake.ObjectsStub
	fakeReturns := fake.objectsReturns
	fake.recordInvocation("Objects", []interface{}{arg1, arg2})
	fake.objectsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBucketHandle) ObjectsCallCount() int {
	fake.objectsMutex.RLock()
	defer fake.objectsMutex.RUnlock()
	return len(fake.objectsArgsForCall)
}

func (fake *FakeBucketHandle) ObjectsCalls(stub func(context.Context, *storagea.Query) storage.ObjectIterator) {
	fake.objectsMutex.Lock()
	defer fake.objectsMutex.Unlock()
	fake.ObjectsStub = stub
}

func (fake *FakeBucketHandle) ObjectsArgsForCall(i int) (context.Context, *storagea.Query) {
	fake.objectsMutex.RLock()
	defer fake.objectsMutex.RUnlock()
	argsForCall := fake.objectsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBucketHandle) ObjectsReturns(result1 storage.ObjectIterator) {
	fake.objectsMutex.Lock()
	defer fake.objectsMutex.Unlock()
	fake.ObjectsStub = nil
	fake.objectsReturns = struct {
		result1 storage.ObjectIterator
	}{result1}
}

func (fake *FakeBucketHandle) ObjectsReturnsOnCall(i int, result1 storage.ObjectIterator) {
	fake.objectsMutex.Lock()
	defer fake.objectsMutex.Unlock()
	fake.ObjectsStub = nil
	if fake.objectsReturnsOnCall == nil {
		fake.objectsReturnsOnCall = make(map[int]struct {
			result1 storage.ObjectIterator
		})
	}
	fake.objectsReturnsOnCall[i] = struct {
		result1 storage.ObjectIterator
	}{result1}
}

func (fake *FakeBucketHandle) Update(arg1 context.Context, arg2 storagea.BucketAttrsToUpdate) (*storagea.BucketAttrs, error) {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 context.Context
		arg2 storagea.BucketAttrsToUpdate
	}{arg1, arg2})
	stub := fake.UpdateStub
	fakeReturns := fake.updateReturns
	fake.recordInvocation("Update", []interface{}{arg1, arg2})
	fake.updateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBucketHandle) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeBucketHandle) UpdateCalls(stub func(context.Context, storagea.BucketAttrsToUpdate) (*storagea.BucketAttrs, error)) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = stub
}

func (fake *FakeBucketHandle) UpdateArgsForCall(i int) (context.Context, storagea.BucketAttrsToUpdate) {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	argsForCall := fake.updateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBucketHandle) UpdateReturns(result1 *storagea.BucketAttrs, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 *storagea.BucketAttrs
		result2 error
	}{result1, result2}
}

func (fake *FakeBucketHandle) UpdateReturnsOnCall(i int, result1 *storagea.BucketAttrs, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 *storagea.BucketAttrs
			result2 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 *storagea.BucketAttrs
		result2 error
	}{result1, result2}
}

func (fake *FakeBucketHandle) UserProject(arg1 string) storage.BucketHandle {
	fake.userProjectMutex.Lock()
	ret, specificReturn := fake.userProjectReturnsOnCall[len(fake.userProjectArgsForCall)]
	fake.userProjectArgsForCall = append(fake.userProjectArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.UserProjectStub
	fakeReturns := fake.userProjectReturns
	fake.recordInvocation("UserProject", []interface{}{arg1})
	fake.userProjectMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBucketHandle) UserProjectCallCount() int {
	fake.userProjectMutex.RLock()
	defer fake.userProjectMutex.RUnlock()
	return len(fake.userProjectArgsForCall)
}

func (fake *FakeBucketHandle) UserProjectCalls(stub func(string) storage.BucketHandle) {
	fake.userProjectMutex.Lock()
	defer fake.userProjectMutex.Unlock()
	fake.UserProjectStub = stub
}

func (fake *FakeBucketHandle) UserProjectArgsForCall(i int) string {
	fake.userProjectMutex.RLock()
	defer fake.userProjectMutex.RUnlock()
	argsForCall := fake.userProjectArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBucketHandle) UserProjectReturns(result1 storage.BucketHandle) {
	fake.userProjectMutex.Lock()
	defer fake.userProjectMutex.Unlock()
	fake.UserProjectStub = nil
	fake.userProjectReturns = struct {
		result1 storage.BucketHandle
	}{result1}
}

func (fake *FakeBucketHandle) UserProjectReturnsOnCall(i int, result1 storage.BucketHandle) {
	fake.userProjectMutex.Lock()
	defer fake.userProjectMutex.Unlock()
	fake.UserProjectStub = nil
	if fake.userProjectReturnsOnCall == nil {
		fake.userProjectReturnsOnCall = make(map[int]struct {
			result1 storage.BucketHandle
		})
	}
	fake.userProjectReturnsOnCall[i] = struct {
		result1 storage.BucketHandle
	}{result1}
}

func (fake *FakeBucketHandle) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.aCLMutex.RLock()
	defer fake.aCLMutex.RUnlock()
	fake.addNotificationMutex.RLock()
	defer fake.addNotificationMutex.RUnlock()
	fake.attrsMutex.RLock()
	defer fake.attrsMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.defaultObjectACLMutex.RLock()
	defer fake.defaultObjectACLMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.deleteNotificationMutex.RLock()
	defer fake.deleteNotificationMutex.RUnlock()
	fake.iAMMutex.RLock()
	defer fake.iAMMutex.RUnlock()
	fake.ifMutex.RLock()
	defer fake.ifMutex.RUnlock()
	fake.lockRetentionPolicyMutex.RLock()
	defer fake.lockRetentionPolicyMutex.RUnlock()
	fake.notificationsMutex.RLock()
	defer fake.notificationsMutex.RUnlock()
	fake.objectMutex.RLock()
	defer fake.objectMutex.RUnlock()
	fake.objectsMutex.RLock()
	defer fake.objectsMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	fake.userProjectMutex.RLock()
	defer fake.userProjectMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBucketHandle) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ storage.BucketHandle = new(FakeBucketHandle)
