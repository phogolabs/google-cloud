// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"context"
	"sync"

	storagea "cloud.google.com/go/storage"
	"github.com/phogolabs/google-cloud/storage"
)

type FakeObjectHandle struct {
	ACLStub        func() storage.ACLHandle
	aCLMutex       sync.RWMutex
	aCLArgsForCall []struct {
	}
	aCLReturns struct {
		result1 storage.ACLHandle
	}
	aCLReturnsOnCall map[int]struct {
		result1 storage.ACLHandle
	}
	AttrsStub        func(context.Context) (*storagea.ObjectAttrs, error)
	attrsMutex       sync.RWMutex
	attrsArgsForCall []struct {
		arg1 context.Context
	}
	attrsReturns struct {
		result1 *storagea.ObjectAttrs
		result2 error
	}
	attrsReturnsOnCall map[int]struct {
		result1 *storagea.ObjectAttrs
		result2 error
	}
	ComposerFromStub        func(...storage.ObjectHandle) storage.Composer
	composerFromMutex       sync.RWMutex
	composerFromArgsForCall []struct {
		arg1 []storage.ObjectHandle
	}
	composerFromReturns struct {
		result1 storage.Composer
	}
	composerFromReturnsOnCall map[int]struct {
		result1 storage.Composer
	}
	CopierFromStub        func(storage.ObjectHandle) storage.Copier
	copierFromMutex       sync.RWMutex
	copierFromArgsForCall []struct {
		arg1 storage.ObjectHandle
	}
	copierFromReturns struct {
		result1 storage.Copier
	}
	copierFromReturnsOnCall map[int]struct {
		result1 storage.Copier
	}
	DeleteStub        func(context.Context) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 context.Context
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	GenerationStub        func(int64) storage.ObjectHandle
	generationMutex       sync.RWMutex
	generationArgsForCall []struct {
		arg1 int64
	}
	generationReturns struct {
		result1 storage.ObjectHandle
	}
	generationReturnsOnCall map[int]struct {
		result1 storage.ObjectHandle
	}
	IfStub        func(storagea.Conditions) storage.ObjectHandle
	ifMutex       sync.RWMutex
	ifArgsForCall []struct {
		arg1 storagea.Conditions
	}
	ifReturns struct {
		result1 storage.ObjectHandle
	}
	ifReturnsOnCall map[int]struct {
		result1 storage.ObjectHandle
	}
	KeyStub        func([]byte) storage.ObjectHandle
	keyMutex       sync.RWMutex
	keyArgsForCall []struct {
		arg1 []byte
	}
	keyReturns struct {
		result1 storage.ObjectHandle
	}
	keyReturnsOnCall map[int]struct {
		result1 storage.ObjectHandle
	}
	NewRangeReaderStub        func(context.Context, int64, int64) (storage.Reader, error)
	newRangeReaderMutex       sync.RWMutex
	newRangeReaderArgsForCall []struct {
		arg1 context.Context
		arg2 int64
		arg3 int64
	}
	newRangeReaderReturns struct {
		result1 storage.Reader
		result2 error
	}
	newRangeReaderReturnsOnCall map[int]struct {
		result1 storage.Reader
		result2 error
	}
	NewReaderStub        func(context.Context) (storage.Reader, error)
	newReaderMutex       sync.RWMutex
	newReaderArgsForCall []struct {
		arg1 context.Context
	}
	newReaderReturns struct {
		result1 storage.Reader
		result2 error
	}
	newReaderReturnsOnCall map[int]struct {
		result1 storage.Reader
		result2 error
	}
	NewWriterStub        func(context.Context) storage.Writer
	newWriterMutex       sync.RWMutex
	newWriterArgsForCall []struct {
		arg1 context.Context
	}
	newWriterReturns struct {
		result1 storage.Writer
	}
	newWriterReturnsOnCall map[int]struct {
		result1 storage.Writer
	}
	ReadCompressedStub        func(bool) storage.ObjectHandle
	readCompressedMutex       sync.RWMutex
	readCompressedArgsForCall []struct {
		arg1 bool
	}
	readCompressedReturns struct {
		result1 storage.ObjectHandle
	}
	readCompressedReturnsOnCall map[int]struct {
		result1 storage.ObjectHandle
	}
	UpdateStub        func(context.Context, storagea.ObjectAttrsToUpdate) (*storagea.ObjectAttrs, error)
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 context.Context
		arg2 storagea.ObjectAttrsToUpdate
	}
	updateReturns struct {
		result1 *storagea.ObjectAttrs
		result2 error
	}
	updateReturnsOnCall map[int]struct {
		result1 *storagea.ObjectAttrs
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeObjectHandle) ACL() storage.ACLHandle {
	fake.aCLMutex.Lock()
	ret, specificReturn := fake.aCLReturnsOnCall[len(fake.aCLArgsForCall)]
	fake.aCLArgsForCall = append(fake.aCLArgsForCall, struct {
	}{})
	stub := fake.ACLStub
	fakeReturns := fake.aCLReturns
	fake.recordInvocation("ACL", []interface{}{})
	fake.aCLMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeObjectHandle) ACLCallCount() int {
	fake.aCLMutex.RLock()
	defer fake.aCLMutex.RUnlock()
	return len(fake.aCLArgsForCall)
}

func (fake *FakeObjectHandle) ACLCalls(stub func() storage.ACLHandle) {
	fake.aCLMutex.Lock()
	defer fake.aCLMutex.Unlock()
	fake.ACLStub = stub
}

func (fake *FakeObjectHandle) ACLReturns(result1 storage.ACLHandle) {
	fake.aCLMutex.Lock()
	defer fake.aCLMutex.Unlock()
	fake.ACLStub = nil
	fake.aCLReturns = struct {
		result1 storage.ACLHandle
	}{result1}
}

func (fake *FakeObjectHandle) ACLReturnsOnCall(i int, result1 storage.ACLHandle) {
	fake.aCLMutex.Lock()
	defer fake.aCLMutex.Unlock()
	fake.ACLStub = nil
	if fake.aCLReturnsOnCall == nil {
		fake.aCLReturnsOnCall = make(map[int]struct {
			result1 storage.ACLHandle
		})
	}
	fake.aCLReturnsOnCall[i] = struct {
		result1 storage.ACLHandle
	}{result1}
}

func (fake *FakeObjectHandle) Attrs(arg1 context.Context) (*storagea.ObjectAttrs, error) {
	fake.attrsMutex.Lock()
	ret, specificReturn := fake.attrsReturnsOnCall[len(fake.attrsArgsForCall)]
	fake.attrsArgsForCall = append(fake.attrsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.AttrsStub
	fakeReturns := fake.attrsReturns
	fake.recordInvocation("Attrs", []interface{}{arg1})
	fake.attrsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeObjectHandle) AttrsCallCount() int {
	fake.attrsMutex.RLock()
	defer fake.attrsMutex.RUnlock()
	return len(fake.attrsArgsForCall)
}

func (fake *FakeObjectHandle) AttrsCalls(stub func(context.Context) (*storagea.ObjectAttrs, error)) {
	fake.attrsMutex.Lock()
	defer fake.attrsMutex.Unlock()
	fake.AttrsStub = stub
}

func (fake *FakeObjectHandle) AttrsArgsForCall(i int) context.Context {
	fake.attrsMutex.RLock()
	defer fake.attrsMutex.RUnlock()
	argsForCall := fake.attrsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeObjectHandle) AttrsReturns(result1 *storagea.ObjectAttrs, result2 error) {
	fake.attrsMutex.Lock()
	defer fake.attrsMutex.Unlock()
	fake.AttrsStub = nil
	fake.attrsReturns = struct {
		result1 *storagea.ObjectAttrs
		result2 error
	}{result1, result2}
}

func (fake *FakeObjectHandle) AttrsReturnsOnCall(i int, result1 *storagea.ObjectAttrs, result2 error) {
	fake.attrsMutex.Lock()
	defer fake.attrsMutex.Unlock()
	fake.AttrsStub = nil
	if fake.attrsReturnsOnCall == nil {
		fake.attrsReturnsOnCall = make(map[int]struct {
			result1 *storagea.ObjectAttrs
			result2 error
		})
	}
	fake.attrsReturnsOnCall[i] = struct {
		result1 *storagea.ObjectAttrs
		result2 error
	}{result1, result2}
}

func (fake *FakeObjectHandle) ComposerFrom(arg1 ...storage.ObjectHandle) storage.Composer {
	fake.composerFromMutex.Lock()
	ret, specificReturn := fake.composerFromReturnsOnCall[len(fake.composerFromArgsForCall)]
	fake.composerFromArgsForCall = append(fake.composerFromArgsForCall, struct {
		arg1 []storage.ObjectHandle
	}{arg1})
	stub := fake.ComposerFromStub
	fakeReturns := fake.composerFromReturns
	fake.recordInvocation("ComposerFrom", []interface{}{arg1})
	fake.composerFromMutex.Unlock()
	if stub != nil {
		return stub(arg1...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeObjectHandle) ComposerFromCallCount() int {
	fake.composerFromMutex.RLock()
	defer fake.composerFromMutex.RUnlock()
	return len(fake.composerFromArgsForCall)
}

func (fake *FakeObjectHandle) ComposerFromCalls(stub func(...storage.ObjectHandle) storage.Composer) {
	fake.composerFromMutex.Lock()
	defer fake.composerFromMutex.Unlock()
	fake.ComposerFromStub = stub
}

func (fake *FakeObjectHandle) ComposerFromArgsForCall(i int) []storage.ObjectHandle {
	fake.composerFromMutex.RLock()
	defer fake.composerFromMutex.RUnlock()
	argsForCall := fake.composerFromArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeObjectHandle) ComposerFromReturns(result1 storage.Composer) {
	fake.composerFromMutex.Lock()
	defer fake.composerFromMutex.Unlock()
	fake.ComposerFromStub = nil
	fake.composerFromReturns = struct {
		result1 storage.Composer
	}{result1}
}

func (fake *FakeObjectHandle) ComposerFromReturnsOnCall(i int, result1 storage.Composer) {
	fake.composerFromMutex.Lock()
	defer fake.composerFromMutex.Unlock()
	fake.ComposerFromStub = nil
	if fake.composerFromReturnsOnCall == nil {
		fake.composerFromReturnsOnCall = make(map[int]struct {
			result1 storage.Composer
		})
	}
	fake.composerFromReturnsOnCall[i] = struct {
		result1 storage.Composer
	}{result1}
}

func (fake *FakeObjectHandle) CopierFrom(arg1 storage.ObjectHandle) storage.Copier {
	fake.copierFromMutex.Lock()
	ret, specificReturn := fake.copierFromReturnsOnCall[len(fake.copierFromArgsForCall)]
	fake.copierFromArgsForCall = append(fake.copierFromArgsForCall, struct {
		arg1 storage.ObjectHandle
	}{arg1})
	stub := fake.CopierFromStub
	fakeReturns := fake.copierFromReturns
	fake.recordInvocation("CopierFrom", []interface{}{arg1})
	fake.copierFromMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeObjectHandle) CopierFromCallCount() int {
	fake.copierFromMutex.RLock()
	defer fake.copierFromMutex.RUnlock()
	return len(fake.copierFromArgsForCall)
}

func (fake *FakeObjectHandle) CopierFromCalls(stub func(storage.ObjectHandle) storage.Copier) {
	fake.copierFromMutex.Lock()
	defer fake.copierFromMutex.Unlock()
	fake.CopierFromStub = stub
}

func (fake *FakeObjectHandle) CopierFromArgsForCall(i int) storage.ObjectHandle {
	fake.copierFromMutex.RLock()
	defer fake.copierFromMutex.RUnlock()
	argsForCall := fake.copierFromArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeObjectHandle) CopierFromReturns(result1 storage.Copier) {
	fake.copierFromMutex.Lock()
	defer fake.copierFromMutex.Unlock()
	fake.CopierFromStub = nil
	fake.copierFromReturns = struct {
		result1 storage.Copier
	}{result1}
}

func (fake *FakeObjectHandle) CopierFromReturnsOnCall(i int, result1 storage.Copier) {
	fake.copierFromMutex.Lock()
	defer fake.copierFromMutex.Unlock()
	fake.CopierFromStub = nil
	if fake.copierFromReturnsOnCall == nil {
		fake.copierFromReturnsOnCall = make(map[int]struct {
			result1 storage.Copier
		})
	}
	fake.copierFromReturnsOnCall[i] = struct {
		result1 storage.Copier
	}{result1}
}

func (fake *FakeObjectHandle) Delete(arg1 context.Context) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.DeleteStub
	fakeReturns := fake.deleteReturns
	fake.recordInvocation("Delete", []interface{}{arg1})
	fake.deleteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeObjectHandle) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeObjectHandle) DeleteCalls(stub func(context.Context) error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeObjectHandle) DeleteArgsForCall(i int) context.Context {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeObjectHandle) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeObjectHandle) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeObjectHandle) Generation(arg1 int64) storage.ObjectHandle {
	fake.generationMutex.Lock()
	ret, specificReturn := fake.generationReturnsOnCall[len(fake.generationArgsForCall)]
	fake.generationArgsForCall = append(fake.generationArgsForCall, struct {
		arg1 int64
	}{arg1})
	stub := fake.GenerationStub
	fakeReturns := fake.generationReturns
	fake.recordInvocation("Generation", []interface{}{arg1})
	fake.generationMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeObjectHandle) GenerationCallCount() int {
	fake.generationMutex.RLock()
	defer fake.generationMutex.RUnlock()
	return len(fake.generationArgsForCall)
}

func (fake *FakeObjectHandle) GenerationCalls(stub func(int64) storage.ObjectHandle) {
	fake.generationMutex.Lock()
	defer fake.generationMutex.Unlock()
	fake.GenerationStub = stub
}

func (fake *FakeObjectHandle) GenerationArgsForCall(i int) int64 {
	fake.generationMutex.RLock()
	defer fake.generationMutex.RUnlock()
	argsForCall := fake.generationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeObjectHandle) GenerationReturns(result1 storage.ObjectHandle) {
	fake.generationMutex.Lock()
	defer fake.generationMutex.Unlock()
	fake.GenerationStub = nil
	fake.generationReturns = struct {
		result1 storage.ObjectHandle
	}{result1}
}

func (fake *FakeObjectHandle) GenerationReturnsOnCall(i int, result1 storage.ObjectHandle) {
	fake.generationMutex.Lock()
	defer fake.generationMutex.Unlock()
	fake.GenerationStub = nil
	if fake.generationReturnsOnCall == nil {
		fake.generationReturnsOnCall = make(map[int]struct {
			result1 storage.ObjectHandle
		})
	}
	fake.generationReturnsOnCall[i] = struct {
		result1 storage.ObjectHandle
	}{result1}
}

func (fake *FakeObjectHandle) If(arg1 storagea.Conditions) storage.ObjectHandle {
	fake.ifMutex.Lock()
	ret, specificReturn := fake.ifReturnsOnCall[len(fake.ifArgsForCall)]
	fake.ifArgsForCall = append(fake.ifArgsForCall, struct {
		arg1 storagea.Conditions
	}{arg1})
	stub := fake.IfStub
	fakeReturns := fake.ifReturns
	fake.recordInvocation("If", []interface{}{arg1})
	fake.ifMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeObjectHandle) IfCallCount() int {
	fake.ifMutex.RLock()
	defer fake.ifMutex.RUnlock()
	return len(fake.ifArgsForCall)
}

func (fake *FakeObjectHandle) IfCalls(stub func(storagea.Conditions) storage.ObjectHandle) {
	fake.ifMutex.Lock()
	defer fake.ifMutex.Unlock()
	fake.IfStub = stub
}

func (fake *FakeObjectHandle) IfArgsForCall(i int) storagea.Conditions {
	fake.ifMutex.RLock()
	defer fake.ifMutex.RUnlock()
	argsForCall := fake.ifArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeObjectHandle) IfReturns(result1 storage.ObjectHandle) {
	fake.ifMutex.Lock()
	defer fake.ifMutex.Unlock()
	fake.IfStub = nil
	fake.ifReturns = struct {
		result1 storage.ObjectHandle
	}{result1}
}

func (fake *FakeObjectHandle) IfReturnsOnCall(i int, result1 storage.ObjectHandle) {
	fake.ifMutex.Lock()
	defer fake.ifMutex.Unlock()
	fake.IfStub = nil
	if fake.ifReturnsOnCall == nil {
		fake.ifReturnsOnCall = make(map[int]struct {
			result1 storage.ObjectHandle
		})
	}
	fake.ifReturnsOnCall[i] = struct {
		result1 storage.ObjectHandle
	}{result1}
}

func (fake *FakeObjectHandle) Key(arg1 []byte) storage.ObjectHandle {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.keyMutex.Lock()
	ret, specificReturn := fake.keyReturnsOnCall[len(fake.keyArgsForCall)]
	fake.keyArgsForCall = append(fake.keyArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	stub := fake.KeyStub
	fakeReturns := fake.keyReturns
	fake.recordInvocation("Key", []interface{}{arg1Copy})
	fake.keyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeObjectHandle) KeyCallCount() int {
	fake.keyMutex.RLock()
	defer fake.keyMutex.RUnlock()
	return len(fake.keyArgsForCall)
}

func (fake *FakeObjectHandle) KeyCalls(stub func([]byte) storage.ObjectHandle) {
	fake.keyMutex.Lock()
	defer fake.keyMutex.Unlock()
	fake.KeyStub = stub
}

func (fake *FakeObjectHandle) KeyArgsForCall(i int) []byte {
	fake.keyMutex.RLock()
	defer fake.keyMutex.RUnlock()
	argsForCall := fake.keyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeObjectHandle) KeyReturns(result1 storage.ObjectHandle) {
	fake.keyMutex.Lock()
	defer fake.keyMutex.Unlock()
	fake.KeyStub = nil
	fake.keyReturns = struct {
		result1 storage.ObjectHandle
	}{result1}
}

func (fake *FakeObjectHandle) KeyReturnsOnCall(i int, result1 storage.ObjectHandle) {
	fake.keyMutex.Lock()
	defer fake.keyMutex.Unlock()
	fake.KeyStub = nil
	if fake.keyReturnsOnCall == nil {
		fake.keyReturnsOnCall = make(map[int]struct {
			result1 storage.ObjectHandle
		})
	}
	fake.keyReturnsOnCall[i] = struct {
		result1 storage.ObjectHandle
	}{result1}
}

func (fake *FakeObjectHandle) NewRangeReader(arg1 context.Context, arg2 int64, arg3 int64) (storage.Reader, error) {
	fake.newRangeReaderMutex.Lock()
	ret, specificReturn := fake.newRangeReaderReturnsOnCall[len(fake.newRangeReaderArgsForCall)]
	fake.newRangeReaderArgsForCall = append(fake.newRangeReaderArgsForCall, struct {
		arg1 context.Context
		arg2 int64
		arg3 int64
	}{arg1, arg2, arg3})
	stub := fake.NewRangeReaderStub
	fakeReturns := fake.newRangeReaderReturns
	fake.recordInvocation("NewRangeReader", []interface{}{arg1, arg2, arg3})
	fake.newRangeReaderMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeObjectHandle) NewRangeReaderCallCount() int {
	fake.newRangeReaderMutex.RLock()
	defer fake.newRangeReaderMutex.RUnlock()
	return len(fake.newRangeReaderArgsForCall)
}

func (fake *FakeObjectHandle) NewRangeReaderCalls(stub func(context.Context, int64, int64) (storage.Reader, error)) {
	fake.newRangeReaderMutex.Lock()
	defer fake.newRangeReaderMutex.Unlock()
	fake.NewRangeReaderStub = stub
}

func (fake *FakeObjectHandle) NewRangeReaderArgsForCall(i int) (context.Context, int64, int64) {
	fake.newRangeReaderMutex.RLock()
	defer fake.newRangeReaderMutex.RUnlock()
	argsForCall := fake.newRangeReaderArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeObjectHandle) NewRangeReaderReturns(result1 storage.Reader, result2 error) {
	fake.newRangeReaderMutex.Lock()
	defer fake.newRangeReaderMutex.Unlock()
	fake.NewRangeReaderStub = nil
	fake.newRangeReaderReturns = struct {
		result1 storage.Reader
		result2 error
	}{result1, result2}
}

func (fake *FakeObjectHandle) NewRangeReaderReturnsOnCall(i int, result1 storage.Reader, result2 error) {
	fake.newRangeReaderMutex.Lock()
	defer fake.newRangeReaderMutex.Unlock()
	fake.NewRangeReaderStub = nil
	if fake.newRangeReaderReturnsOnCall == nil {
		fake.newRangeReaderReturnsOnCall = make(map[int]struct {
			result1 storage.Reader
			result2 error
		})
	}
	fake.newRangeReaderReturnsOnCall[i] = struct {
		result1 storage.Reader
		result2 error
	}{result1, result2}
}

func (fake *FakeObjectHandle) NewReader(arg1 context.Context) (storage.Reader, error) {
	fake.newReaderMutex.Lock()
	ret, specificReturn := fake.newReaderReturnsOnCall[len(fake.newReaderArgsForCall)]
	fake.newReaderArgsForCall = append(fake.newReaderArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.NewReaderStub
	fakeReturns := fake.newReaderReturns
	fake.recordInvocation("NewReader", []interface{}{arg1})
	fake.newReaderMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeObjectHandle) NewReaderCallCount() int {
	fake.newReaderMutex.RLock()
	defer fake.newReaderMutex.RUnlock()
	return len(fake.newReaderArgsForCall)
}

func (fake *FakeObjectHandle) NewReaderCalls(stub func(context.Context) (storage.Reader, error)) {
	fake.newReaderMutex.Lock()
	defer fake.newReaderMutex.Unlock()
	fake.NewReaderStub = stub
}

func (fake *FakeObjectHandle) NewReaderArgsForCall(i int) context.Context {
	fake.newReaderMutex.RLock()
	defer fake.newReaderMutex.RUnlock()
	argsForCall := fake.newReaderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeObjectHandle) NewReaderReturns(result1 storage.Reader, result2 error) {
	fake.newReaderMutex.Lock()
	defer fake.newReaderMutex.Unlock()
	fake.NewReaderStub = nil
	fake.newReaderReturns = struct {
		result1 storage.Reader
		result2 error
	}{result1, result2}
}

func (fake *FakeObjectHandle) NewReaderReturnsOnCall(i int, result1 storage.Reader, result2 error) {
	fake.newReaderMutex.Lock()
	defer fake.newReaderMutex.Unlock()
	fake.NewReaderStub = nil
	if fake.newReaderReturnsOnCall == nil {
		fake.newReaderReturnsOnCall = make(map[int]struct {
			result1 storage.Reader
			result2 error
		})
	}
	fake.newReaderReturnsOnCall[i] = struct {
		result1 storage.Reader
		result2 error
	}{result1, result2}
}

func (fake *FakeObjectHandle) NewWriter(arg1 context.Context) storage.Writer {
	fake.newWriterMutex.Lock()
	ret, specificReturn := fake.newWriterReturnsOnCall[len(fake.newWriterArgsForCall)]
	fake.newWriterArgsForCall = append(fake.newWriterArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.NewWriterStub
	fakeReturns := fake.newWriterReturns
	fake.recordInvocation("NewWriter", []interface{}{arg1})
	fake.newWriterMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeObjectHandle) NewWriterCallCount() int {
	fake.newWriterMutex.RLock()
	defer fake.newWriterMutex.RUnlock()
	return len(fake.newWriterArgsForCall)
}

func (fake *FakeObjectHandle) NewWriterCalls(stub func(context.Context) storage.Writer) {
	fake.newWriterMutex.Lock()
	defer fake.newWriterMutex.Unlock()
	fake.NewWriterStub = stub
}

func (fake *FakeObjectHandle) NewWriterArgsForCall(i int) context.Context {
	fake.newWriterMutex.RLock()
	defer fake.newWriterMutex.RUnlock()
	argsForCall := fake.newWriterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeObjectHandle) NewWriterReturns(result1 storage.Writer) {
	fake.newWriterMutex.Lock()
	defer fake.newWriterMutex.Unlock()
	fake.NewWriterStub = nil
	fake.newWriterReturns = struct {
		result1 storage.Writer
	}{result1}
}

func (fake *FakeObjectHandle) NewWriterReturnsOnCall(i int, result1 storage.Writer) {
	fake.newWriterMutex.Lock()
	defer fake.newWriterMutex.Unlock()
	fake.NewWriterStub = nil
	if fake.newWriterReturnsOnCall == nil {
		fake.newWriterReturnsOnCall = make(map[int]struct {
			result1 storage.Writer
		})
	}
	fake.newWriterReturnsOnCall[i] = struct {
		result1 storage.Writer
	}{result1}
}

func (fake *FakeObjectHandle) ReadCompressed(arg1 bool) storage.ObjectHandle {
	fake.readCompressedMutex.Lock()
	ret, specificReturn := fake.readCompressedReturnsOnCall[len(fake.readCompressedArgsForCall)]
	fake.readCompressedArgsForCall = append(fake.readCompressedArgsForCall, struct {
		arg1 bool
	}{arg1})
	stub := fake.ReadCompressedStub
	fakeReturns := fake.readCompressedReturns
	fake.recordInvocation("ReadCompressed", []interface{}{arg1})
	fake.readCompressedMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeObjectHandle) ReadCompressedCallCount() int {
	fake.readCompressedMutex.RLock()
	defer fake.readCompressedMutex.RUnlock()
	return len(fake.readCompressedArgsForCall)
}

func (fake *FakeObjectHandle) ReadCompressedCalls(stub func(bool) storage.ObjectHandle) {
	fake.readCompressedMutex.Lock()
	defer fake.readCompressedMutex.Unlock()
	fake.ReadCompressedStub = stub
}

func (fake *FakeObjectHandle) ReadCompressedArgsForCall(i int) bool {
	fake.readCompressedMutex.RLock()
	defer fake.readCompressedMutex.RUnlock()
	argsForCall := fake.readCompressedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeObjectHandle) ReadCompressedReturns(result1 storage.ObjectHandle) {
	fake.readCompressedMutex.Lock()
	defer fake.readCompressedMutex.Unlock()
	fake.ReadCompressedStub = nil
	fake.readCompressedReturns = struct {
		result1 storage.ObjectHandle
	}{result1}
}

func (fake *FakeObjectHandle) ReadCompressedReturnsOnCall(i int, result1 storage.ObjectHandle) {
	fake.readCompressedMutex.Lock()
	defer fake.readCompressedMutex.Unlock()
	fake.ReadCompressedStub = nil
	if fake.readCompressedReturnsOnCall == nil {
		fake.readCompressedReturnsOnCall = make(map[int]struct {
			result1 storage.ObjectHandle
		})
	}
	fake.readCompressedReturnsOnCall[i] = struct {
		result1 storage.ObjectHandle
	}{result1}
}

func (fake *FakeObjectHandle) Update(arg1 context.Context, arg2 storagea.ObjectAttrsToUpdate) (*storagea.ObjectAttrs, error) {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 context.Context
		arg2 storagea.ObjectAttrsToUpdate
	}{arg1, arg2})
	stub := fake.UpdateStub
	fakeReturns := fake.updateReturns
	fake.recordInvocation("Update", []interface{}{arg1, arg2})
	fake.updateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeObjectHandle) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeObjectHandle) UpdateCalls(stub func(context.Context, storagea.ObjectAttrsToUpdate) (*storagea.ObjectAttrs, error)) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = stub
}

func (fake *FakeObjectHandle) UpdateArgsForCall(i int) (context.Context, storagea.ObjectAttrsToUpdate) {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	argsForCall := fake.updateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeObjectHandle) UpdateReturns(result1 *storagea.ObjectAttrs, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 *storagea.ObjectAttrs
		result2 error
	}{result1, result2}
}

func (fake *FakeObjectHandle) UpdateReturnsOnCall(i int, result1 *storagea.ObjectAttrs, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 *storagea.ObjectAttrs
			result2 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 *storagea.ObjectAttrs
		result2 error
	}{result1, result2}
}

func (fake *FakeObjectHandle) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.aCLMutex.RLock()
	defer fake.aCLMutex.RUnlock()
	fake.attrsMutex.RLock()
	defer fake.attrsMutex.RUnlock()
	fake.composerFromMutex.RLock()
	defer fake.composerFromMutex.RUnlock()
	fake.copierFromMutex.RLock()
	defer fake.copierFromMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.generationMutex.RLock()
	defer fake.generationMutex.RUnlock()
	fake.ifMutex.RLock()
	defer fake.ifMutex.RUnlock()
	fake.keyMutex.RLock()
	defer fake.keyMutex.RUnlock()
	fake.newRangeReaderMutex.RLock()
	defer fake.newRangeReaderMutex.RUnlock()
	fake.newReaderMutex.RLock()
	defer fake.newReaderMutex.RUnlock()
	fake.newWriterMutex.RLock()
	defer fake.newWriterMutex.RUnlock()
	fake.readCompressedMutex.RLock()
	defer fake.readCompressedMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeObjectHandle) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ storage.ObjectHandle = new(FakeObjectHandle)
